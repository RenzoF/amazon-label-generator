var libbcmath = { PLUS: "+", MINUS: "-", BASE: 10, scale: 0, bc_num: function () { this.n_sign = null, this.n_len = null, this.n_scale = null, this.n_value = null, this.toString = function () { var n, e; return e = this.n_value.join(""), n = (this.n_sign == libbcmath.PLUS ? "" : this.n_sign) + e.substr(0, this.n_len), this.n_scale > 0 && (n += "." + e.substr(this.n_len, this.n_scale)), n }, this.setScale = function (n) { for (; this.n_scale < n;)this.n_value.push(0), this.n_scale++; for (; this.n_scale > n;)this.n_value.pop(), this.n_scale--; return this } }, bc_new_num: function (n, e) { var l; return l = new libbcmath.bc_num, l.n_sign = libbcmath.PLUS, l.n_len = n, l.n_scale = e, l.n_value = libbcmath.safe_emalloc(1, n + e, 0), libbcmath.memset(l.n_value, 0, 0, n + e), l }, safe_emalloc: function (n, e, l) { return Array(n * e + l) }, bc_init_num: function () { return new libbcmath.bc_new_num(1, 0) }, _bc_rm_leading_zeros: function (n) { for (; 0 === n.n_value[0] && n.n_len > 1;)n.n_value.shift(), n.n_len-- }, php_str2num: function (n) { var e; return e = n.indexOf("."), -1 == e ? libbcmath.bc_str2num(n, 0) : libbcmath.bc_str2num(n, n.length - e) }, CH_VAL: function (n) { return n - "0" }, BCD_CHAR: function (n) { return n + "0" }, isdigit: function (n) { return !isNaN(parseInt(n, 10)) }, bc_str2num: function (n, e) { var l, t, _, i, a, b, c; for (l = n.split(""), _ = 0, i = 0, a = 0, b = !1, "+" !== l[_] && "-" !== l[_] || _++; "0" === l[_];)_++; for (; l[_] % 1 == 0;)_++, i++; for ("." === l[_] && _++; l[_] % 1 == 0;)_++, a++; if (l[_] || i + a === 0) return libbcmath.bc_init_num(); for (a = libbcmath.MIN(a, e), 0 === i && (b = !0, i = 1), t = libbcmath.bc_new_num(i, a), _ = 0, "-" === l[_] ? (t.n_sign = libbcmath.MINUS, _++) : (t.n_sign = libbcmath.PLUS, "+" === l[_] && _++); "0" === l[_];)_++; for (c = 0, b && (t.n_value[c++] = 0, i = 0); i > 0; i--)t.n_value[c++] = libbcmath.CH_VAL(l[_++]); if (a > 0) for (_++; a > 0; a--)t.n_value[c++] = libbcmath.CH_VAL(l[_++]); return t }, cint: function (n) { void 0 === n && (n = 0); var e = parseInt(n, 10); return isNaN(e) && (e = 0), e }, MIN: function (n, e) { return n > e ? e : n }, MAX: function (n, e) { return n > e ? n : e }, ODD: function (n) { return 1 & n }, memset: function (n, e, l, t) { var _; for (_ = 0; _ < t; _++)n[e + _] = l }, memcpy: function (n, e, l, t, _) { var i; for (i = 0; i < _; i++)n[e + i] = l[t + i]; return !0 }, bc_is_zero: function (n) { var e, l; for (e = n.n_len + n.n_scale, l = 0; e > 0 && 0 === n.n_value[l++];)e--; return 0 === e }, bc_out_of_memory: function () { throw new Error("(BC) Out of memory") }, _one_mult: function (n, e, l, t, _, i) { var a, b, c, u; if (0 === t) libbcmath.memset(_, 0, 0, l); else if (1 == t) libbcmath.memcpy(_, i, n, e, l); else { for (c = e + l - 1, u = i + l - 1, a = 0; l-- > 0;)b = n[c--] * t + a, _[u--] = b % libbcmath.BASE, a = Math.floor(b / libbcmath.BASE); 0 != a && (_[u] = a) } }, bc_divide: function (n, e, l) { var t, _, i, a, b, c, u, m, r, o, s, h, f, v, g, p, S, d, y, M, N, U; if (libbcmath.bc_is_zero(e)) return -1; if (libbcmath.bc_is_zero(n)) return libbcmath.bc_new_num(1, l); for (0 === e.n_scale && 1 === e.n_len && 1 === e.n_value[0] && (t = libbcmath.bc_new_num(n.n_len, l), t.n_sign = n.n_sign == e.n_sign ? libbcmath.PLUS : libbcmath.MINUS, libbcmath.memset(t.n_value, n.n_len, 0, l), libbcmath.memcpy(t.n_value, 0, n.n_value, 0, n.n_len + libbcmath.MIN(n.n_scale, l))), h = e.n_scale, c = e.n_len + h - 1; h > 0 && 0 === e.n_value[c--];)h--; for (o = n.n_len + h, m = n.n_scale - h, v = m < l ? l - m : 0, _ = libbcmath.safe_emalloc(1, n.n_len + n.n_scale, v + 2), null === _ && libbcmath.bc_out_of_memory(), libbcmath.memset(_, 0, 0, n.n_len + n.n_scale + v + 2), libbcmath.memcpy(_, 1, n.n_value, 0, n.n_len + n.n_scale), s = e.n_len + h, i = libbcmath.safe_emalloc(1, s, 1), null === i && libbcmath.bc_out_of_memory(), libbcmath.memcpy(i, 0, e.n_value, 0, s), i[s] = 0, c = 0; 0 === i[c];)c++, s--; if (s > o + l ? (f = l + 1, N = !0) : (N = !1, f = s > o ? l + 1 : o - s + l + 1), t = libbcmath.bc_new_num(f - l, l), libbcmath.memset(t.n_value, 0, 0, f), M = libbcmath.safe_emalloc(1, s, 1), null === M && libbcmath.bc_out_of_memory(), !N) for (U = Math.floor(10 / (e.n_value[c] + 1)), 1 != U && (libbcmath._one_mult(_, 0, o + m + v + 1, U, _, 0), libbcmath._one_mult(e.n_value, c, s, U, e.n_value, c)), p = 0, u = s > o ? s - o : 0; p <= o + l - s;) { if (S = e.n_value[c] == _[p] ? 9 : Math.floor((10 * _[p] + _[p + 1]) / e.n_value[c]), e.n_value[c + 1] * S > 10 * (10 * _[p] + _[p + 1] - e.n_value[c] * S) + _[p + 2] && (S--, e.n_value[c + 1] * S > 10 * (10 * _[p] + _[p + 1] - e.n_value[c] * S) + _[p + 2] && S--), d = 0, 0 !== S) for (M[0] = 0, libbcmath._one_mult(e.n_value, c, s, S, M, 1), a = p + s, b = s, g = 0; g < s + 1; g++)r = b < 0 ? _[a] - 0 - d : _[a] - M[b--] - d, r < 0 ? (r += 10, d = 1) : d = 0, _[a--] = r; if (1 == d) { for (S--, a = p + s, b = s - 1, y = 0, g = 0; g < s; g++)r = b < 0 ? _[a] + 0 + y : _[a] + e.n_value[b--] + y, r > 9 ? (r -= 10, y = 1) : y = 0, _[a--] = r; 1 == y && (_[a] = (_[a] + 1) % 10) } t.n_value[u++] = S, p++ } return t.n_sign = n.n_sign == e.n_sign ? libbcmath.PLUS : libbcmath.MINUS, libbcmath.bc_is_zero(t) && (t.n_sign = libbcmath.PLUS), libbcmath._bc_rm_leading_zeros(t), t } }; "undefined" != typeof module && void 0 !== module.exports && (module.exports = libbcmath);